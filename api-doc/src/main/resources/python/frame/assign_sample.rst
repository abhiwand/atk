Assign classes to rows.

Randomly assign classes to rows given a vector of percentages.
The table receives an additional column that contains a random label.
The random label is generated by a probability distribution function.
The distribution function is specified by the sample_percentages, a list of
floating point values, which add up to 1.
The labels are non-negative integers drawn from the range
[ 0, len(sample_percentages) - 1].
Optionally, the user can specify a list of strings to be used as the labels.
If the number of labels is 3, the labels will default to "TR", "TE" and "VA".

Parameters
----------
sample_percentages : list of float
    Entries are non-negative and sum to 1. (See the note below.)
    If the *i*'th entry of the  list is *p*,
    then then each row receives label *i* with independent probability *p*.

sample_labels : [ str | list of str ] (optional)
    Names to be used for the split classes.
    Defaults "TR", "TE", "VA" when the length of *sample_percentages* is 3,
    and defaults to Sample#0, Sample#1, ... otherwise.

output_column : str (optional)
    Name of the new column which holds the labels generated by the function

random_seed : int (optional)
    Random seed used to generate the labels.
    Defaults to 0.

Probability Validation and Floating Point Precision
---------------------------------------------------

The sample percentages provided by the user are preserved to at least eight decimal places, but beyond this
there may be small changes do to floating point imprecision.

Ideally, the values in sample_percentages should some to one.
However, due to the limitations of floating point representation, it is sometimes possible that
numbers that *look* like they should sum to 1 when printed in the Python REPL in fact do not sum exactly to 1
when converted to 64bit floating point numbers.

Floating point imprecision of values in sample_percentages is handled as follows:
1. The engine validates that the sum of probabilities sums to 1.0 within eight decimal places and returns an error
if the sum falls outside of this range.
2. The probability of the final class is clamped so that each row receives a valid label with probability one.


Examples
--------
For this example, *my_frame* is a BigFrame object accessing a frame with data.
Append a new column *sample_bin* to the frame;
Assign the value in the new column to "train", "test", or "validate"::

    my_frame.assign_sample([0.3, 0.3, 0.4], ["train", "test", "validate"])

Now *my_frame*, the frame accessed by BigFrame, has a new column named
"sample_bin" and each row contains one of the values "train", "test", or
"validate".
Values in the other columns are unaffected.

