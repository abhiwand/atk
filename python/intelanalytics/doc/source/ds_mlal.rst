===========================
Machine Learning Algorithms
===========================

.. _ds_mlal_K-Clique Percolation Algorithm:

------------------------------
K-Clique Percolation Algorithm
------------------------------

Overview
========

Detecting clusters or communities in large real-world graphs such as large social or information networks is a problem of considerable interest.
*K-Clique* percolation is a community detection algorithm proposed by *Palla et. al.* [1]_ .
The algorithm looks for communities that may have overlap, in other words, shared nodes.
It is based on the concept that the internal edges of a community are likely to form cliques due to their high density.
On the other hand, it is unlikely that intercommunity edges form cliques.
*Palla et al.* use the term *k-clique* to indicate a complete graph with :math:`k` vertices.
A *k-clique* community is the largest connected subgraph obtained by the union of a *k-clique* and of all *k-cliques* which are connected to it.
A *k-clique* community is identified by making a *k-clique* “roll" over adjacent *k-cliques*, where rolling means rotating a *k-clique* about
the :math:`k-1` vertices it shares with any adjacent *k-clique*.
The complexity of this procedure can be extremely high, and the computation time needed to find all *k-cliques* of a graph is an
exponentially growing function of the graph size.
This is one of the major reasons that has prevented *k-clique* communities from being extracted from large-scale networks.

Distributed K-Clique
====================

*Varamesh et. al.* [2]_ proposed a map-reduce based distributed computing model to *k-clique* communities.
The *k-clique percolation algorithm* implemented here has been developed based on the model proposed by *Varamesh et. al.*. 

The Algorithm
=============

The *k-clique percolation* proposed by *Varamesh et. al.* has two main steps - a) *k-clique* extraction, and b) *k-clique* community detection. 

The raw input of the algorithm is a graph :math:`G` represented as an edge list.
That is, an unstructured list of edges represented as pairs :math:`\{u,v\}`.
In this map-reduce based algorithm, the facts of graph :math:`G` has always been represented as key-value pairs.

Definition:
    If two *k-cliques* of :math:`G`, :math:`C` and :math:`D`, share :math:`k - 1` nodes, they are said to be adjacent,
    and in particular they are adjacent through the :math:`k-1` clique :math:`C \cap D`.

Suppose, 

| a. for a set :math:`U \subseteq V(G)`, and :math:`v \in V(G)`, :math:`U + v` denotes :math:`U \cup \{v \}` and :math:`U - v` denotes :math:`U \backslash \{ v \}`.
| b. :math:`C_{k}` denotes the set of all :math:`k`-cliques of :math:`G`. 
| c. For each :math:`U \subseteq V(G)`, :math:`v \in V(G)`, :math:`U \to` NbrsOf :math:`(v)` means that all vertices of :math:`U` are neighbors of :math:`v`.
| d. For each :math:`U \subseteq V(G)`, :math:`U \to Clique` means that :math:`U` is a clique of :math:`G`.
| e. For each :math:`U,V \subseteq V(G)`, :math:`U \to V` means that :math:`U` is a clique in :math:`G`,
    :math:`U \cap V = \phi`, and that for all :math:`v \in V`, :math:`U + v` is a clique in :math:`G`.


Definition:
    :math:`U \to V` is said to be maximal if :math:`V` contains all the :math:`v \in V(G) - U` so that :math:`U+v` is a clique of :math:`G`.

Notice that whenever :math:`U` is a set of :math:`k` vertices and :math:`U \to V`, then the sets  :math:`U + v` for :math:`v \in V` are all :math:`(k+1)` cliques of :math:`G` and they are adjacent through :math:`U`.
Furthermore,  if :math:`U \to V` is maximal, then these are ALL of the :math:`(k+1)` cliques adjacent through :math:`U`. 

Thus, to find all of the :math:`(k+1)` cliques of :math:`G` and their adjacencies (and thus the :math:`k+1` clique graph) it suffices to calculate the following set of facts:

.. math::

    e_{k+1} = \{ U \to V: |U| = k,  U \to V\ is\ maximal \}

The edge list of the :math:`(k+1)` clique graph can then be generated by emitting every pair :math:`\{v, w\}` for :math:`v`, :math:`w \in V`,  with :math:`v \neq w` and :math:`U \to V \in e_{k+1}`.

As this is not an optimized idea, *Varamesh et. al.* has made necessary changes and introduced an optimal way to search this.

:math:`e_{k+1}` encodes each :math:`(k+1)` clique :math:`(k+1)` many times, because for every :math:`U=\{u_{1}, ... u_{k+1}\}`,
that is a :math:`k+1` clique of :math:`G`, there is a distinct fact :math:`(U - u_{i}) \to V_{i} \in e_{k+1}` for each :math:`1 \leq i \leq k+1`.
To reduce this duplicate construction, authors has used the following set of facts.

.. math::
   
   f_{k+1} = \{ U \to V: |U| = k,  U \to V\ is\ maximal\ so\ that\ \forall v \in V, \forall u \in U\ u < v \}

That is, for :math:`U \to V \in f_{k+1}`, :math:`V` contains every :math:`v` so that :math:`U+v` is a :math:`(k+1)` clique
and :math:`\forall u \in U\ u < v`.

Notice that for every set :math:`U=\{u_{1}, ... u_{k+1}\}` that is a :math:`k+1` clique of :math:`G`, there is exactly one  :math:`U ^{*} \to V \in f_{k+1} , v \in V` such that :math:`U ^{*} + v = U`

The algorithm does not iteratively construct the sets :math:`f_{k+1}`, rather, it alternates between them and the following sets :math:`f ^{*}_{k+1}`:

.. math::
   
   f^{*}_{k+1} = \{ U \to V: |U| = k, U \to V\ is\ maximal\ so\ that\ \forall v \in V, \forall u \in U\ u > v \}

That is, for :math:`U \to V \in f ^{*}_{k+1}`, :math:`V` contains every :math:`v` so that :math:`U+v` is a :math:`(k+1)` clique
and :math:`\forall u \in U\ u > v`.

Depending upon whether the value of ‘k’ is odd or even, the alteration takes place.

* ‘k’ is even:

    * Step 1: It is a map-only step. 

        For each :math:`U \to v \in g_{k-1}`, infer :math:`U+v \to Clique`.

    * Step 2: It has both map and reduce phase.

        Group pairs by their keys (that is, by :math:`U`).
        Let :math:`u_{k-1} = max\ U`.
        Now for each :math:`U \to v \in g_{k-1}` and :math:`U \to w \in g_{k-1}` with :math:`v \neq w`,
        infer :math:`U - u_{k-1} + v + w \to` NbrsOf :math:`(u_{k-1})`.
        Notice that for each :math:`x \in U - u_{k-1} + v + w, x < u_{k-1}`.

    * Step 3: It is a reducer step.

        At the reducer collecting on key :math:`U = \{u_{1}, ... u_{k+1}\}`.
        If the key-value pair :math:`U \to Clique` appears, then, for each :math:`v` such that :math:`U \to` NbrsOf :math:`(v)` appears and output :math:`U \to v`.

* ‘k’ is odd: 

    * Step 1: It is a map-only step. 

        For each :math:`U \to v \in g ^{*}_{k-1}`, infer :math:`U+v \to Clique`

    * Step 2: It has both map and reduce phase.

        Group pairs by their keys (that is, by :math:`U`).
        Let :math:`u_{k-1} = min\ U`.
        Now for each :math:`U \to v \in g_{k-1}` and :math:`U \to w \in g_{k-1}` with :math:`v \neq w`,
        infer :math:`U - u_{k-1} + v + w \to` NbrsOf :math:`(u_{k-1})`.
        Notice that for each :math:`x \in U - u_{k-1} + v + w, x > u_{k-1}`.

    * Step 3: It is a reducer step.

        At the reducer collecting on key :math:`U = \{u_{1}, ... u_{k+1}\}`.
        If the key-value pair :math:`U \to Clique` appears, then, for each :math:`v` such that :math:`U \to` NbrsOf :math:`(v)` appears and output :math:`U \to v`.

The next step is to create the *k-clique* graph.
The *k-clique* graph of G is a graph whose nodes are the :math:`k`-cliques of :math:`G` and there is an edge between every pair of adjacent *k-cliques*.

After the iterations we have

.. math::

    g_{k} = \{ U \to v: |U| = k-1, U+v\ is\ a\ clique, \forall u \in U\ u < v \}

or

.. math::

    g^{*}_{k} = \{ U \to v: |U| = k-1, U+v\ is\ a\ clique, \forall u \in U\ u > v \}

To construct the *k-clique* graph from either of these sets, we emit pairs of :math:`(k-1)` cliques and *k-cliques* extending them as follows: 

    From :math:`U \to v` emit every :math:`(U + v - w, U+v)` where :math:`w \in U + v`

The reducer then gathers on the keys (the :math:`k-1` cliques).
Every :math:`k` clique landing at the same reducer is adjacent in the clique graph.

On this *k-clique* graph, we run a connected component analysis to find the communities of *k-cliques*.
We have used the MapReduce based connected component algorithm to find *k-clique* communities.
The resultant set is a key value pair where key is the vertex ID and value is a set of communities it belongs to.

Once the communities have been identified for each vertex, the algorithm updates the vertices of the original graph with the new
property (name will be given by user) and corresponding value as the set of communities it belongs to.

Usage
=====

Syntax:
-------
::

    graph.ml.kclique_percolation (
        cliqueSize, 
        communityPropertyDefaultLabel
    )

Arguments:
----------

*cliqueSize*

    Parameter determining clique-size (the number ‘k’) used to determine communities.
    Must be at least 1.
    Large values of cliqueSize result in fewer, smaller communities that are more connected

*communityPropertyDefaultLabel*

    Name of the community property of vertex that will be updated/created in the input graph


Implementation
==============

Input data format:
------------------

The *k-clique* percolation (*kclique_percolation*) algorithm takes as input data represented in CSV, JSON, or XML format.
In this example, we use a CSV file.
Each CSV file consists of at least four columns.
The source column is a list of source IDs.
The input_value column is the prior value for the source vertex.
In this example, it is vector with two elements in it.
The sum of the elements in this vector is 1.
The target column is a list of target IDs.
The weight column is the weight on the edge from the source to the target.

Data Import:
------------

To import the *kclique_percolation* input data, a python call (we provide) has to be used.
Please refer to the example for the usage.

Graph construction:
-------------------

After importing the raw data, you register which fields to use for the source vertex, which fields to use for the target vertex,
and then construct a graph from your input data.

Run *kclique_percolation* algorithm:
------------------------------------

After graph construction, you are able to run the *kclique_percolation* algorithm.
The algorithm takes two parameters as arguments (listed above).

Returns:
--------

The algorithm updates the input graph vertex with updated property named in *“communityPropertyDefaultLabel”*, mentioned in the argument list.

Example
=======
::

    from intelanalytics import *
    dataset = r"datasets/kclique_edges.csv"
    schema = [("source", int64), ("target", int64)]
    csvfile = CsvFile(dataset, schema)
    f = BigFrame(csvfile)
    source = VertexRule("source", f.source)
    target = VertexRule("target", f.target)
    edge = EdgeRule("edge", target, source)
    g = BigGraph([target, source, edge], "mygraph")
    g.ml.kclique_percolation(cliqueSize = 3, communityPropertyDefaultLabel = "Community")

.. _Uncovering the overlapping community structure of complex networks in nature and society: http://hal.elte.hu/cfinder/wiki/papers/communitylettm.pdf

.. rubric:: Footnotes

.. [1] G. Palla, I. Derenyi, I. Farkas, and T. Vicsek. "`Uncovering the overlapping community structure of complex networks in nature and society`_". Nature, 435:814, 2005
.. [2] Varamesh, A.; Akbari, M.K.; Fereiduni, M.; Sharifian, S.; Bagheri, A., "Distributed Clique Percolation based community detection on social networks using MapReduce," Information and Knowledge Technology (IKT), 2013 5th Conference on , vol., no., pp.478,483, 28-30 May 2013
